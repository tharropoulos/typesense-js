{"version":3,"sources":["/home/fanis/code/typesense/typesense-js/dist/Typesense.min.js","../node_modules/loglevel/lib/loglevel.js","../src/Typesense/Configuration.ts","../src/Typesense/Errors/index.ts","../src/Typesense/Errors/TypesenseError.ts","../src/Typesense/Errors/HTTPError.ts","../src/Typesense/Errors/MissingConfigurationError.ts","../src/Typesense/Errors/ObjectAlreadyExists.ts","../src/Typesense/Errors/ObjectNotFound.ts","../src/Typesense/Errors/ObjectUnprocessable.ts","../src/Typesense/Errors/RequestMalformed.ts","../src/Typesense/Errors/RequestUnauthorized.ts","../src/Typesense/Errors/ServerError.ts","../src/Typesense/Errors/ImportError.ts","../src/Typesense/ApiCall.ts","../src/Typesense/Documents.ts","../src/Typesense/Conversations.ts"],"names":["require_loglevel","__commonJSMin","exports","module","root","definition","noop","undefinedType","isIE","logMethods","_loggersByName","defaultLogger","bindMethod","obj","methodName","method","traceForIE","realMethod","replaceLoggingMethods","level","i","enableLoggingWhenConsoleArrives","defaultMethodFactory","_level","_loggerName","Logger","name","factory","self","inheritedLevel","defaultLevel","userLevel","storageKey","persistLevelIfPossible","levelNum","levelName","getPersistedLevel","storedLevel","cookie","cookieName","location","clearPersistedLevel","normalizeLevel","input","persist","childName","initialLevel","logger","_log","Errors_exports","__export","HTTPError","ImportError","MissingConfigurationError","ObjectAlreadyExists","ObjectNotFound","ObjectUnprocessable","RequestMalformed","RequestUnauthorized","ServerError","TypesenseError","message","importResults","Configuration","options","node","key","array","j","APIKEYHEADERNAME","HEALTHY","UNHEALTHY","ApiCall","configuration","endpoint","queryParameters","abortSignal","responseType","bodyParameters","additionalHeaders","requestType","skipConnectionTimeout","enableKeepAlive","requestNumber","lastException"],"mappings":"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","file":"/home/fanis/code/typesense/typesense-js/dist/Typesense.min.js","sourcesContent":[null,"/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    var _loggersByName = {};\n    var defaultLogger = null;\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods() {\n        /*jshint validthis:true */\n        var level = this.getLevel();\n\n        // Replace the actual methods.\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, this.name);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n\n        // Return any important warnings.\n        if (typeof console === undefinedType && level < this.levels.SILENT) {\n            return \"No console available for logging\";\n        }\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, _level, _loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, factory) {\n      // Private instance variables.\n      var self = this;\n      /**\n       * The level inherited from a parent logger (or a global default). We\n       * cache this here rather than delegating to the parent so that it stays\n       * in sync with the actual logging methods that we have installed (the\n       * parent could change levels but we might not have rebuilt the loggers\n       * in this child yet).\n       * @type {number}\n       */\n      var inheritedLevel;\n      /**\n       * The default level for this logger, if any. If set, this overrides\n       * `inheritedLevel`.\n       * @type {number|null}\n       */\n      var defaultLevel;\n      /**\n       * A user-specific level for this logger. If set, this overrides\n       * `defaultLevel`.\n       * @type {number|null}\n       */\n      var userLevel;\n\n      var storageKey = \"loglevel\";\n      if (typeof name === \"string\") {\n        storageKey += \":\" + name;\n      } else if (typeof name === \"symbol\") {\n        storageKey = undefined;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var cookieName = encodeURIComponent(storageKey);\n                  var location = cookie.indexOf(cookieName + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(\n                          cookie.slice(location + cookieName.length + 1)\n                      )[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      function clearPersistedLevel() {\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage.removeItem(storageKey);\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n          } catch (ignore) {}\n      }\n\n      function normalizeLevel(input) {\n          var level = input;\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              return level;\n          } else {\n              throw new TypeError(\"log.setLevel() called with invalid level: \" + input);\n          }\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          if (userLevel != null) {\n            return userLevel;\n          } else if (defaultLevel != null) {\n            return defaultLevel;\n          } else {\n            return inheritedLevel;\n          }\n      };\n\n      self.setLevel = function (level, persist) {\n          userLevel = normalizeLevel(level);\n          if (persist !== false) {  // defaults to true\n              persistLevelIfPossible(userLevel);\n          }\n\n          // NOTE: in v2, this should call rebuild(), which updates children.\n          return replaceLoggingMethods.call(self);\n      };\n\n      self.setDefaultLevel = function (level) {\n          defaultLevel = normalizeLevel(level);\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.resetLevel = function () {\n          userLevel = null;\n          clearPersistedLevel();\n          replaceLoggingMethods.call(self);\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      self.rebuild = function () {\n          if (defaultLogger !== self) {\n              inheritedLevel = normalizeLevel(defaultLogger.getLevel());\n          }\n          replaceLoggingMethods.call(self);\n\n          if (defaultLogger === self) {\n              for (var childName in _loggersByName) {\n                _loggersByName[childName].rebuild();\n              }\n          }\n      };\n\n      // Initialize all the internal levels.\n      inheritedLevel = normalizeLevel(\n          defaultLogger ? defaultLogger.getLevel() : \"WARN\"\n      );\n      var initialLevel = getPersistedLevel();\n      if (initialLevel != null) {\n          userLevel = normalizeLevel(initialLevel);\n      }\n      replaceLoggingMethods.call(self);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    defaultLogger = new Logger();\n\n    defaultLogger.getLogger = function getLogger(name) {\n        if ((typeof name !== \"symbol\" && typeof name !== \"string\") || name === \"\") {\n            throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n            logger = _loggersByName[name] = new Logger(\n                name,\n                defaultLogger.methodFactory\n            );\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    // ES6 default export, for compatibility\n    defaultLogger['default'] = defaultLogger;\n\n    return defaultLogger;\n}));\n","import * as logger from \"loglevel\"\nimport { Logger, LogLevelDesc } from \"loglevel\"\nimport { MissingConfigurationError } from \"./Errors\"\nimport type { Agent as HTTPAgent } from \"http\"\nimport type { Agent as HTTPSAgent } from \"https\"\n\nexport interface NodeConfiguration {\n  host: string\n  port: number\n  protocol: string\n  path?: string\n  url?: string\n}\n\nexport interface NodeConfigurationWithHostname {\n  host: string\n  port: number\n  protocol: string\n  path?: string\n}\n\nexport interface NodeConfigurationWithUrl {\n  url: string\n}\n\nexport interface ConfigurationOptions {\n  apiKey: string\n  nodes:\n    | NodeConfiguration[]\n    | NodeConfigurationWithHostname[]\n    | NodeConfigurationWithUrl[]\n  randomizeNodes?: boolean\n  /**\n   * @deprecated\n   * masterNode is now consolidated to nodes, starting with Typesense Server v0.12'\n   */\n  masterNode?:\n    | NodeConfiguration\n    | NodeConfigurationWithHostname\n    | NodeConfigurationWithUrl\n  /**\n   * @deprecated\n   * readReplicaNodes is now consolidated to nodes, starting with Typesense Server v0.12'\n   */\n  readReplicaNodes?:\n    | NodeConfiguration[]\n    | NodeConfigurationWithHostname[]\n    | NodeConfigurationWithUrl[]\n  nearestNode?:\n    | NodeConfiguration\n    | NodeConfigurationWithHostname\n    | NodeConfigurationWithUrl\n  connectionTimeoutSeconds?: number\n  timeoutSeconds?: number\n  healthcheckIntervalSeconds?: number\n  numRetries?: number\n  retryIntervalSeconds?: number\n  sendApiKeyAsQueryParam?: boolean | undefined\n  useServerSideSearchCache?: boolean\n  cacheSearchResultsForSeconds?: number\n  additionalHeaders?: Record<string, string>\n\n  logLevel?: LogLevelDesc\n  logger?: Logger\n\n  /**\n   * Set a custom HTTP Agent\n   *\n   * This is helpful for eg, to enable keepAlive which helps prevents ECONNRESET socket hang up errors\n   *    Usage:\n   *      const { Agent: HTTPAgent } = require(\"http\");\n   *      ...\n   *      httpAgent: new HTTPAgent({ keepAlive: true }),\n   * @type {HTTPAgent}\n   */\n  httpAgent?: HTTPAgent\n\n  /**\n   * Set a custom HTTPS Agent\n   *\n   * This is helpful for eg, to enable keepAlive which helps prevents ECONNRESET socket hang up errors\n   *    Usage:\n   *      const { Agent: HTTPSAgent } = require(\"https\");\n   *      ...\n   *      httpsAgent: new HTTPSAgent({ keepAlive: true }),\n   * @type {HTTPSAgent}\n   */\n  httpsAgent?: HTTPSAgent\n\n  /**\n   * Set a custom paramsSerializer\n   *\n   * See axios documentation for more information on how to use this parameter: https://axios-http.com/docs/req_config\n   *  This is helpful for handling React Native issues like this: https://github.com/axios/axios/issues/6102#issuecomment-2085301397\n   * @type {any}\n   */\n  paramsSerializer?: any\n}\n\nexport default class Configuration {\n  readonly nodes:\n    | NodeConfiguration[]\n    | NodeConfigurationWithHostname[]\n    | NodeConfigurationWithUrl[]\n  readonly nearestNode?:\n    | NodeConfiguration\n    | NodeConfigurationWithHostname\n    | NodeConfigurationWithUrl\n  readonly connectionTimeoutSeconds: number\n  readonly healthcheckIntervalSeconds: number\n  readonly numRetries: number\n  readonly retryIntervalSeconds: number\n  readonly apiKey: string\n  readonly sendApiKeyAsQueryParam?: boolean\n  readonly cacheSearchResultsForSeconds: number\n  readonly useServerSideSearchCache: boolean\n  readonly logger: Logger\n  readonly logLevel: LogLevelDesc\n  readonly additionalHeaders?: Record<string, string>\n  readonly httpAgent?: HTTPAgent\n  readonly httpsAgent?: HTTPSAgent\n  readonly paramsSerializer?: any\n\n  constructor(options: ConfigurationOptions) {\n    this.nodes = options.nodes || []\n    this.nodes = this.nodes\n      .map((node) => this.setDefaultPathInNode(node))\n      .map((node) => this.setDefaultPortInNode(node))\n      .map((node) => ({ ...node })) as NodeConfiguration[] // Make a deep copy\n\n    if (options.randomizeNodes == null) {\n      options.randomizeNodes = true\n    }\n\n    if (options.randomizeNodes === true) {\n      this.shuffleArray(this.nodes)\n    }\n\n    this.nearestNode = options.nearestNode\n    this.nearestNode = this.setDefaultPathInNode(this.nearestNode)\n    this.nearestNode = this.setDefaultPortInNode(this.nearestNode)\n\n    this.connectionTimeoutSeconds =\n      options.connectionTimeoutSeconds || options.timeoutSeconds || 5\n    this.healthcheckIntervalSeconds = options.healthcheckIntervalSeconds || 60\n    this.numRetries =\n      options.numRetries ||\n      this.nodes.length + (this.nearestNode == null ? 0 : 1) ||\n      3\n    this.retryIntervalSeconds = options.retryIntervalSeconds || 0.1\n\n    this.apiKey = options.apiKey\n    this.sendApiKeyAsQueryParam = options.sendApiKeyAsQueryParam // We will set a default for this in Client and SearchClient\n\n    this.cacheSearchResultsForSeconds =\n      options.cacheSearchResultsForSeconds || 0 // Disable client-side cache by default\n    this.useServerSideSearchCache = options.useServerSideSearchCache || false\n\n    this.logger = options.logger || logger\n    this.logLevel = options.logLevel || \"warn\"\n    this.logger.setLevel(this.logLevel)\n\n    this.additionalHeaders = options.additionalHeaders\n\n    this.httpAgent = options.httpAgent\n    this.httpsAgent = options.httpsAgent\n\n    this.paramsSerializer = options.paramsSerializer\n\n    this.showDeprecationWarnings(options)\n    this.validate()\n  }\n\n  validate(): boolean {\n    if (this.nodes == null || this.nodes.length === 0 || this.validateNodes()) {\n      throw new MissingConfigurationError(\n        \"Ensure that nodes[].protocol, nodes[].host and nodes[].port are set\"\n      )\n    }\n\n    if (\n      this.nearestNode != null &&\n      this.isNodeMissingAnyParameters(this.nearestNode)\n    ) {\n      throw new MissingConfigurationError(\n        \"Ensure that nearestNodes.protocol, nearestNodes.host and nearestNodes.port are set\"\n      )\n    }\n\n    if (this.apiKey == null) {\n      throw new MissingConfigurationError(\"Ensure that apiKey is set\")\n    }\n\n    return true\n  }\n\n  private validateNodes(): boolean {\n    return this.nodes.some((node) => {\n      return this.isNodeMissingAnyParameters(node)\n    })\n  }\n\n  private isNodeMissingAnyParameters(\n    node:\n      | NodeConfiguration\n      | NodeConfigurationWithHostname\n      | NodeConfigurationWithUrl\n  ): boolean {\n    return (\n      ![\"protocol\", \"host\", \"port\", \"path\"].every((key) => {\n        return node.hasOwnProperty(key)\n      }) && node[\"url\"] == null\n    )\n  }\n\n  private setDefaultPathInNode(\n    node:\n      | NodeConfiguration\n      | NodeConfigurationWithHostname\n      | NodeConfigurationWithUrl\n      | undefined\n  ):\n    | NodeConfiguration\n    | NodeConfigurationWithHostname\n    | NodeConfigurationWithUrl\n    | undefined {\n    if (node != null && !node.hasOwnProperty(\"path\")) {\n      node[\"path\"] = \"\"\n    }\n    return node\n  }\n\n  private setDefaultPortInNode(\n    node:\n      | NodeConfiguration\n      | NodeConfigurationWithHostname\n      | NodeConfigurationWithUrl\n      | undefined\n  ):\n    | NodeConfiguration\n    | NodeConfigurationWithHostname\n    | NodeConfigurationWithUrl\n    | undefined {\n    if (\n      node != null &&\n      !node.hasOwnProperty(\"port\") &&\n      node.hasOwnProperty(\"protocol\")\n    ) {\n      switch (node[\"protocol\"]) {\n        case \"https\":\n          node[\"port\"] = 443\n          break\n        case \"http\":\n          node[\"port\"] = 80\n          break\n      }\n    }\n    return node\n  }\n\n  private showDeprecationWarnings(options: ConfigurationOptions): void {\n    if (options.timeoutSeconds) {\n      this.logger.warn(\n        \"Deprecation warning: timeoutSeconds is now renamed to connectionTimeoutSeconds\"\n      )\n    }\n    if (options.masterNode) {\n      this.logger.warn(\n        \"Deprecation warning: masterNode is now consolidated to nodes, starting with Typesense Server v0.12\"\n      )\n    }\n    if (options.readReplicaNodes) {\n      this.logger.warn(\n        \"Deprecation warning: readReplicaNodes is now consolidated to nodes, starting with Typesense Server v0.12\"\n      )\n    }\n  }\n\n  private shuffleArray(array) {\n    for (let i = array.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1))\n      ;[array[i], array[j]] = [array[j], array[i]]\n    }\n  }\n}\n","import HTTPError from \"./HTTPError\";\nimport MissingConfigurationError from \"./MissingConfigurationError\";\nimport ObjectAlreadyExists from \"./ObjectAlreadyExists\";\nimport ObjectNotFound from \"./ObjectNotFound\";\nimport ObjectUnprocessable from \"./ObjectUnprocessable\";\nimport RequestMalformed from \"./RequestMalformed\";\nimport RequestUnauthorized from \"./RequestUnauthorized\";\nimport ServerError from \"./ServerError\";\nimport ImportError from \"./ImportError\";\nimport TypesenseError from \"./TypesenseError\";\n\nexport {\n  HTTPError,\n  MissingConfigurationError,\n  ObjectAlreadyExists,\n  ObjectNotFound,\n  ObjectUnprocessable,\n  RequestMalformed,\n  RequestUnauthorized,\n  ServerError,\n  TypesenseError,\n  ImportError,\n};\n","export default class TypesenseError extends Error {\n  httpStatus?: number;\n\n  // Source: https://stackoverflow.com/a/58417721/123545\n  constructor(message?: string) {\n    super(message);\n    this.name = new.target.name;\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n}\n","import TypesenseError from \"./TypesenseError\";\n\nexport default class HTTPError extends TypesenseError {}\n","import TypesenseError from \"./TypesenseError\";\n\nexport default class MissingConfigurationError extends TypesenseError {}\n","import TypesenseError from \"./TypesenseError\";\n\nexport default class ObjectAlreadyExists extends TypesenseError {}\n","import TypesenseError from \"./TypesenseError\";\n\nexport default class ObjectNotFound extends TypesenseError {}\n","import TypesenseError from \"./TypesenseError\";\n\nexport default class ObjectUnprocessable extends TypesenseError {}\n","import TypesenseError from \"./TypesenseError\";\n\nexport default class RequestMalformed extends TypesenseError {}\n","import TypesenseError from \"./TypesenseError\";\n\nexport default class RequestUnauthorized extends TypesenseError {}\n","import TypesenseError from \"./TypesenseError\";\n\nexport default class ServerError extends TypesenseError {}\n","import TypesenseError from \"./TypesenseError\";\nimport { ImportResponseFail } from \"../Documents\";\n\nexport default class ImportError extends TypesenseError {\n  importResults: ImportResponseFail;\n  constructor(message, importResults) {\n    super(message);\n    this.importResults = importResults;\n  }\n}\n","import axios, { AxiosRequestConfig, AxiosResponse, Method } from \"axios\";\nimport { Logger } from \"loglevel\";\nimport {\n  HTTPError,\n  ObjectAlreadyExists,\n  ObjectNotFound,\n  ObjectUnprocessable,\n  RequestMalformed,\n  RequestUnauthorized,\n  ServerError,\n} from \"./Errors\";\nimport TypesenseError from \"./Errors/TypesenseError\";\nimport Configuration, { NodeConfiguration } from \"./Configuration\";\nimport { Agent as HTTPAgent } from \"http\";\nimport { Agent as HTTPSAgent } from \"https\";\n\nconst APIKEYHEADERNAME = \"X-TYPESENSE-API-KEY\";\nconst HEALTHY = true;\nconst UNHEALTHY = false;\n\ninterface Node extends NodeConfiguration {\n  isHealthy: boolean;\n  index: string | number;\n}\n\nexport default class ApiCall {\n  private readonly apiKey: string;\n  private readonly nodes: Node[];\n  private readonly nearestNode: Node;\n  private readonly connectionTimeoutSeconds: number;\n  private readonly healthcheckIntervalSeconds: number;\n  private readonly retryIntervalSeconds: number;\n  private readonly sendApiKeyAsQueryParam?: boolean;\n  private readonly numRetriesPerRequest: number;\n  private readonly additionalUserHeaders?: Record<string, string>;\n\n  private readonly logger: Logger;\n  private currentNodeIndex: number;\n\n  constructor(private configuration: Configuration) {\n    this.apiKey = this.configuration.apiKey;\n    this.nodes =\n      this.configuration.nodes == null\n        ? this.configuration.nodes\n        : JSON.parse(JSON.stringify(this.configuration.nodes)); // Make a copy, since we'll be adding additional metadata to the nodes\n    this.nearestNode =\n      this.configuration.nearestNode == null\n        ? this.configuration.nearestNode\n        : JSON.parse(JSON.stringify(this.configuration.nearestNode));\n    this.connectionTimeoutSeconds = this.configuration.connectionTimeoutSeconds;\n    this.healthcheckIntervalSeconds =\n      this.configuration.healthcheckIntervalSeconds;\n    this.numRetriesPerRequest = this.configuration.numRetries;\n    this.retryIntervalSeconds = this.configuration.retryIntervalSeconds;\n    this.sendApiKeyAsQueryParam = this.configuration.sendApiKeyAsQueryParam;\n    this.additionalUserHeaders = this.configuration.additionalHeaders;\n\n    this.logger = this.configuration.logger;\n\n    this.initializeMetadataForNodes();\n    this.currentNodeIndex = -1;\n  }\n\n  async get<T>(\n    endpoint: string,\n    queryParameters: any = {},\n    {\n      abortSignal = null,\n      responseType = undefined,\n    }: {\n      abortSignal?: any;\n      responseType?: AxiosRequestConfig[\"responseType\"] | undefined;\n    } = {},\n  ): Promise<T> {\n    return this.performRequest<T>(\"get\", endpoint, {\n      queryParameters,\n      abortSignal,\n      responseType,\n    });\n  }\n\n  async delete<T>(endpoint: string, queryParameters: any = {}): Promise<T> {\n    return this.performRequest<T>(\"delete\", endpoint, { queryParameters });\n  }\n\n  async post<T>(\n    endpoint: string,\n    bodyParameters: any = {},\n    queryParameters: any = {},\n    additionalHeaders: any = {},\n  ): Promise<T> {\n    return this.performRequest<T>(\"post\", endpoint, {\n      queryParameters,\n      bodyParameters,\n      additionalHeaders,\n    });\n  }\n\n  async put<T>(\n    endpoint: string,\n    bodyParameters: any = {},\n    queryParameters: any = {},\n  ): Promise<T> {\n    return this.performRequest<T>(\"put\", endpoint, {\n      queryParameters,\n      bodyParameters,\n    });\n  }\n\n  async patch<T>(\n    endpoint: string,\n    bodyParameters: any = {},\n    queryParameters: any = {},\n  ): Promise<T> {\n    return this.performRequest<T>(\"patch\", endpoint, {\n      queryParameters,\n      bodyParameters,\n    });\n  }\n\n  async performRequest<T>(\n    requestType: Method,\n    endpoint: string,\n    {\n      queryParameters = null,\n      bodyParameters = null,\n      additionalHeaders = {},\n      abortSignal = null,\n      responseType = undefined,\n      skipConnectionTimeout = false,\n      enableKeepAlive = undefined,\n    }: {\n      queryParameters?: any;\n      bodyParameters?: any;\n      additionalHeaders?: any;\n      abortSignal?: any;\n      responseType?: AxiosRequestConfig[\"responseType\"] | undefined;\n      skipConnectionTimeout?: boolean;\n      enableKeepAlive?: boolean | undefined;\n    },\n  ): Promise<T> {\n    this.configuration.validate();\n\n    const requestNumber = Date.now();\n    let lastException;\n    this.logger.debug(\n      `Request #${requestNumber}: Performing ${requestType.toUpperCase()} request: ${endpoint}`,\n    );\n    for (\n      let numTries = 1;\n      numTries <= this.numRetriesPerRequest + 1;\n      numTries++\n    ) {\n      const node = this.getNextNode(requestNumber);\n      this.logger.debug(\n        `Request #${requestNumber}: Attempting ${requestType.toUpperCase()} request Try #${numTries} to Node ${\n          node.index\n        }`,\n      );\n\n      if (abortSignal && abortSignal.aborted) {\n        return Promise.reject(new Error(\"Request aborted by caller.\"));\n      }\n\n      let abortListener;\n\n      try {\n        const requestOptions: AxiosRequestConfig = {\n          method: requestType,\n          url: this.uriFor(endpoint, node),\n          headers: Object.assign(\n            {},\n            this.defaultHeaders(),\n            additionalHeaders,\n            this.additionalUserHeaders,\n          ),\n          maxContentLength: Infinity,\n          maxBodyLength: Infinity,\n          responseType,\n          validateStatus: (status) => {\n            /* Override default validateStatus, which only considers 2xx a success.\n                In our case, if the server returns any HTTP code, we will handle it below.\n                We do this to be able to raise custom errors based on response code.\n             */\n            return status > 0;\n          },\n          transformResponse: [\n            (data, headers) => {\n              let transformedData = data;\n              if (\n                headers !== undefined &&\n                typeof data === \"string\" &&\n                headers[\"content-type\"] &&\n                headers[\"content-type\"].startsWith(\"application/json\")\n              ) {\n                transformedData = JSON.parse(data);\n              }\n              return transformedData;\n            },\n          ],\n        };\n\n        if (skipConnectionTimeout !== true) {\n          requestOptions.timeout = this.connectionTimeoutSeconds * 1000;\n        }\n\n        if (queryParameters && Object.keys(queryParameters).length !== 0) {\n          requestOptions.params = queryParameters;\n        }\n\n        if (this.sendApiKeyAsQueryParam) {\n          requestOptions.params = requestOptions.params || {};\n          requestOptions.params[\"x-typesense-api-key\"] = this.apiKey;\n        }\n\n        if (this.configuration.httpAgent) {\n          this.logger.debug(\n            `Request #${requestNumber}: Using custom httpAgent`,\n          );\n          requestOptions.httpAgent = this.configuration.httpAgent;\n        } else if (enableKeepAlive === true) {\n          this.logger.debug(`Request #${requestNumber}: Enabling KeepAlive`);\n          requestOptions.httpAgent = new HTTPAgent({ keepAlive: true });\n        }\n\n        if (this.configuration.httpsAgent) {\n          this.logger.debug(\n            `Request #${requestNumber}: Using custom httpsAgent`,\n          );\n          requestOptions.httpsAgent = this.configuration.httpsAgent;\n        } else if (enableKeepAlive === true) {\n          this.logger.debug(`Request #${requestNumber}: Enabling keepAlive`);\n          requestOptions.httpsAgent = new HTTPSAgent({ keepAlive: true });\n        }\n\n        if (this.configuration.paramsSerializer) {\n          this.logger.debug(\n            `Request #${requestNumber}: Using custom paramsSerializer`,\n          );\n          requestOptions.paramsSerializer = this.configuration.paramsSerializer;\n        }\n\n        if (\n          bodyParameters &&\n          ((typeof bodyParameters === \"string\" &&\n            bodyParameters.length !== 0) ||\n            (typeof bodyParameters === \"object\" &&\n              Object.keys(bodyParameters).length !== 0))\n        ) {\n          requestOptions.data = bodyParameters;\n        }\n\n        // Translate from user-provided AbortController to the Axios request cancel mechanism.\n        if (abortSignal) {\n          const cancelToken = axios.CancelToken;\n          const source = cancelToken.source();\n          abortListener = () => source.cancel();\n          abortSignal.addEventListener(\"abort\", abortListener);\n          requestOptions.cancelToken = source.token;\n        }\n\n        const response = await axios(requestOptions);\n        if (response.status >= 1 && response.status <= 499) {\n          // Treat any status code > 0 and < 500 to be an indication that node is healthy\n          // We exclude 0 since some clients return 0 when request fails\n          this.setNodeHealthcheck(node, HEALTHY);\n        }\n        this.logger.debug(\n          `Request #${requestNumber}: Request to Node ${node.index} was made. Response Code was ${response.status}.`,\n        );\n\n        if (response.status >= 200 && response.status < 300) {\n          // If response is 2xx return a resolved promise\n          return Promise.resolve(response.data);\n        } else if (response.status < 500) {\n          // Next, if response is anything but 5xx, don't retry, return a custom error\n          return Promise.reject(\n            this.customErrorForResponse(response, response.data?.message),\n          );\n        } else {\n          // Retry all other HTTP errors (HTTPStatus > 500)\n          // This will get caught by the catch block below\n          throw this.customErrorForResponse(response, response.data?.message);\n        }\n      } catch (error: any) {\n        // This block handles retries for HTTPStatus > 500 and network layer issues like connection timeouts\n        this.setNodeHealthcheck(node, UNHEALTHY);\n        lastException = error;\n        this.logger.warn(\n          `Request #${requestNumber}: Request to Node ${\n            node.index\n          } failed due to \"${error.code} ${error.message}${\n            error.response == null\n              ? \"\"\n              : \" - \" + JSON.stringify(error.response?.data)\n          }\"`,\n        );\n        // this.logger.debug(error.stack)\n        this.logger.warn(\n          `Request #${requestNumber}: Sleeping for ${this.retryIntervalSeconds}s and then retrying request...`,\n        );\n        await this.timer(this.retryIntervalSeconds);\n      } finally {\n        if (abortSignal && abortListener) {\n          abortSignal.removeEventListener(\"abort\", abortListener);\n        }\n      }\n    }\n    this.logger.debug(\n      `Request #${requestNumber}: No retries left. Raising last error`,\n    );\n    return Promise.reject(lastException);\n  }\n\n  // Attempts to find the next healthy node, looping through the list of nodes once.\n  //   But if no healthy nodes are found, it will just return the next node, even if it's unhealthy\n  //     so we can try the request for good measure, in case that node has become healthy since\n  getNextNode(requestNumber = 0): Node {\n    // Check if nearestNode is set and is healthy, if so return it\n    if (this.nearestNode != null) {\n      this.logger.debug(\n        `Request #${requestNumber}: Nodes Health: Node ${\n          this.nearestNode.index\n        } is ${this.nearestNode.isHealthy === true ? \"Healthy\" : \"Unhealthy\"}`,\n      );\n      if (\n        this.nearestNode.isHealthy === true ||\n        this.nodeDueForHealthcheck(this.nearestNode, requestNumber)\n      ) {\n        this.logger.debug(\n          `Request #${requestNumber}: Updated current node to Node ${this.nearestNode.index}`,\n        );\n        return this.nearestNode;\n      }\n      this.logger.debug(\n        `Request #${requestNumber}: Falling back to individual nodes`,\n      );\n    }\n\n    // Fallback to nodes as usual\n    this.logger.debug(\n      `Request #${requestNumber}: Nodes Health: ${this.nodes\n        .map(\n          (node) =>\n            `Node ${node.index} is ${\n              node.isHealthy === true ? \"Healthy\" : \"Unhealthy\"\n            }`,\n        )\n        .join(\" || \")}`,\n    );\n    let candidateNode: Node = this.nodes[0];\n    for (let i = 0; i <= this.nodes.length; i++) {\n      this.currentNodeIndex = (this.currentNodeIndex + 1) % this.nodes.length;\n      candidateNode = this.nodes[this.currentNodeIndex];\n      if (\n        candidateNode.isHealthy === true ||\n        this.nodeDueForHealthcheck(candidateNode, requestNumber)\n      ) {\n        this.logger.debug(\n          `Request #${requestNumber}: Updated current node to Node ${candidateNode.index}`,\n        );\n        return candidateNode;\n      }\n    }\n\n    // None of the nodes are marked healthy, but some of them could have become healthy since last health check.\n    //  So we will just return the next node.\n    this.logger.debug(\n      `Request #${requestNumber}: No healthy nodes were found. Returning the next node, Node ${candidateNode.index}`,\n    );\n    return candidateNode;\n  }\n\n  nodeDueForHealthcheck(node, requestNumber = 0): boolean {\n    const isDueForHealthcheck =\n      Date.now() - node.lastAccessTimestamp >\n      this.healthcheckIntervalSeconds * 1000;\n    if (isDueForHealthcheck) {\n      this.logger.debug(\n        `Request #${requestNumber}: Node ${node.index} has exceeded healtcheckIntervalSeconds of ${this.healthcheckIntervalSeconds}. Adding it back into rotation.`,\n      );\n    }\n    return isDueForHealthcheck;\n  }\n\n  initializeMetadataForNodes(): void {\n    if (this.nearestNode != null) {\n      this.nearestNode.index = \"nearestNode\";\n      this.setNodeHealthcheck(this.nearestNode, HEALTHY);\n    }\n\n    this.nodes.forEach((node, i) => {\n      node.index = i;\n      this.setNodeHealthcheck(node, HEALTHY);\n    });\n  }\n\n  setNodeHealthcheck(node, isHealthy): void {\n    node.isHealthy = isHealthy;\n    node.lastAccessTimestamp = Date.now();\n  }\n\n  uriFor(endpoint: string, node): string {\n    if (node.url != null) {\n      return `${node.url}${endpoint}`;\n    }\n    return `${node.protocol}://${node.host}:${node.port}${node.path}${endpoint}`;\n  }\n\n  defaultHeaders(): any {\n    const defaultHeaders = {};\n    if (!this.sendApiKeyAsQueryParam) {\n      defaultHeaders[APIKEYHEADERNAME] = this.apiKey;\n    }\n    defaultHeaders[\"Content-Type\"] = \"application/json\";\n    return defaultHeaders;\n  }\n\n  async timer(seconds): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, seconds * 1000));\n  }\n\n  customErrorForResponse(\n    response: AxiosResponse,\n    messageFromServer: string,\n  ): TypesenseError {\n    let errorMessage = `Request failed with HTTP code ${response.status}`;\n    if (\n      typeof messageFromServer === \"string\" &&\n      messageFromServer.trim() !== \"\"\n    ) {\n      errorMessage += ` | Server said: ${messageFromServer}`;\n    }\n\n    let error = new TypesenseError(errorMessage);\n\n    if (response.status === 400) {\n      error = new RequestMalformed(errorMessage);\n    } else if (response.status === 401) {\n      error = new RequestUnauthorized(errorMessage);\n    } else if (response.status === 404) {\n      error = new ObjectNotFound(errorMessage);\n    } else if (response.status === 409) {\n      error = new ObjectAlreadyExists(errorMessage);\n    } else if (response.status === 422) {\n      error = new ObjectUnprocessable(errorMessage);\n    } else if (response.status >= 500 && response.status <= 599) {\n      error = new ServerError(errorMessage);\n    } else {\n      error = new HTTPError(errorMessage);\n    }\n\n    error.httpStatus = response.status;\n\n    return error;\n  }\n}\n","import type { ReadStream } from \"fs\";\nimport ApiCall from \"./ApiCall\";\nimport Configuration from \"./Configuration\";\nimport { ImportError } from \"./Errors\";\nimport { SearchOnlyDocuments } from \"./SearchOnlyDocuments\";\n\n// Todo: use generic to extract filter_by values\nexport interface DeleteQuery {\n  filter_by: string;\n  batch_size?: number;\n  ignore_not_found?: boolean;\n}\n\nexport interface DeleteResponse {\n  num_deleted: number;\n}\n\ninterface ImportResponseSuccess {\n  success: true;\n}\n\nexport interface ImportResponseFail {\n  success: false;\n  error: string;\n  document: DocumentSchema;\n  code: number;\n}\n\nexport type ImportResponse = ImportResponseSuccess | ImportResponseFail;\n\nexport type DocumentSchema = Record<string, any>;\n\nexport interface SearchParamsWithPreset extends Partial<SearchParams> {\n  preset: string;\n}\n\ntype OperationMode = \"off\" | \"always\" | \"fallback\";\nexport interface SearchParams {\n  // From https://typesense.org/docs/latest/api/documents.html#arguments\n  q?: string;\n  query_by?: string | string[];\n  query_by_weights?: string | number[];\n  prefix?: string | boolean | boolean[]; // default: true\n  filter_by?: string;\n  enable_lazy_filter?: boolean; // default: false\n  sort_by?: string | string[]; // default: text match desc\n  facet_by?: string | string[];\n  max_facet_values?: number;\n  facet_sample_threshold?: number;\n  facet_sample_percent?: number;\n  facet_query?: string;\n  facet_query_num_typos?: number;\n  facet_return_parent?: string;\n  page?: number; // default: 1\n  per_page?: number; // default: 10, max 250\n  group_by?: string | string[];\n  group_limit?: number; // default:\n  group_missing_values?: boolean;\n  include_fields?: string | string[];\n  exclude_fields?: string | string[];\n  highlight_fields?: string | string[]; // default: all queried fields\n  highlight_full_fields?: string | string[]; // default: all fields\n  highlight_affix_num_tokens?: number; // default: 4\n  highlight_start_tag?: string; // default: <mark>\n  highlight_end_tag?: string; // default: </mark>\n  enable_highlight_v1?: boolean;\n  snippet_threshold?: number; // default: 30\n  num_typos?: string | number | number[]; // default: 2\n  min_len_1typo?: number;\n  min_len_2typo?: number;\n  split_join_tokens?: OperationMode;\n  exhaustive_search?: boolean;\n  drop_tokens_threshold?: number; // default: 10\n  typo_tokens_threshold?: number; // default: 100\n  pinned_hits?: string | string[];\n  hidden_hits?: string | string[];\n  limit_hits?: number; // default: no limit\n  pre_segmented_query?: boolean;\n  enable_overrides?: boolean;\n  prioritize_exact_match?: boolean; // default: true\n  prioritize_token_position?: boolean;\n  prioritize_num_matching_fields?: boolean;\n  search_cutoff_ms?: number;\n  use_cache?: boolean;\n  max_candidates?: number;\n  infix?: OperationMode | OperationMode[];\n  preset?: string;\n  text_match_type?: \"max_score\" | \"max_weight\";\n  vector_query?: string;\n  \"x-typesense-api-key\"?: string;\n  \"x-typesense-user-id\"?: string;\n  offset?: number;\n  limit?: number;\n  stopwords?: string;\n  conversation?: boolean;\n  conversation_model_id?: string;\n  conversation_id?: string;\n  voice_query?: string;\n}\n\ntype SearchResponseHighlightObject = {\n  matched_tokens?: string[];\n  snippet?: string;\n  value?: string;\n};\n\nexport type SearchResponseHighlight<T> = T extends string | number\n  ? SearchResponseHighlightObject\n  : {\n      [TAttribute in keyof T]?: SearchResponseHighlight<T[TAttribute]>;\n    };\n\nexport interface SearchResponseHit<T extends DocumentSchema> {\n  curated?: true;\n  highlights?: [\n    {\n      field: keyof T;\n      snippet?: string;\n      value?: string;\n      snippets?: string[];\n      indices?: number[];\n      matched_tokens: string[][] | string[];\n    },\n  ];\n  highlight: SearchResponseHighlight<T>;\n  document: T;\n  text_match: number;\n  text_match_info?: {\n    best_field_score: string; // To prevent scores from being truncated by JSON spec\n    best_field_weight: number;\n    fields_matched: number;\n    score: string; // To prevent scores from being truncated by JSON spec\n    tokens_matched: number;\n  };\n}\n\nexport interface SearchResponseFacetCountSchema<T extends DocumentSchema> {\n  counts: {\n    count: number;\n    highlighted: string;\n    value: string;\n  }[];\n  field_name: keyof T;\n  stats: {\n    avg?: number;\n    max?: number;\n    min?: number;\n    sum?: number;\n  };\n}\n\nexport interface SearchResponseRequestParams {\n  collection_name?: string;\n  q?: string;\n  page?: number;\n  per_page?: number;\n  first_q?: string;\n  voice_query?: {\n    transcribed_query?: string;\n  };\n}\n\n// Todo: we could infer whether this is a grouped response by adding the search params as a generic\nexport interface SearchResponse<T extends DocumentSchema> {\n  facet_counts?: SearchResponseFacetCountSchema<T>[];\n  found: number;\n  found_docs?: number;\n  out_of: number;\n  page: number;\n  request_params: SearchResponseRequestParams;\n  search_time_ms: number;\n  search_cutoff?: boolean;\n  hits?: SearchResponseHit<T>[];\n  grouped_hits?: {\n    group_key: string[];\n    hits: SearchResponseHit<T>[];\n    found?: number;\n  }[];\n  conversation?: {\n    answer: string;\n    conversation_history: {\n      conversation: object[];\n      id: string;\n      last_updated: number;\n      ttl: number;\n    };\n    conversation_id: string;\n    query: string;\n  };\n}\n\nexport interface DocumentWriteParameters {\n  dirty_values?: \"coerce_or_reject\" | \"coerce_or_drop\" | \"drop\" | \"reject\";\n  action?: \"create\" | \"update\" | \"upsert\" | \"emplace\";\n}\n\nexport interface UpdateByFilterParameters {\n  filter_by?: string;\n}\n\nexport interface UpdateByFilterResponse {\n  num_updated: number;\n}\n\nexport interface DocumentImportParameters extends DocumentWriteParameters {\n  batch_size?: number;\n  return_doc?: boolean;\n  return_id?: boolean;\n}\n\nexport interface DocumentsExportParameters {\n  filter_by?: string;\n  include_fields?: string;\n  exclude_fields?: string;\n}\n\nexport interface SearchableDocuments<T extends DocumentSchema> {\n  search(\n    searchParameters: SearchParams | SearchParamsWithPreset,\n    options: SearchOptions,\n  ): Promise<SearchResponse<T>>;\n  clearCache(): void;\n}\n\nexport interface WriteableDocuments<T> {\n  create(document: T, options: DocumentWriteParameters): Promise<T>;\n  upsert(document: T, options: DocumentWriteParameters): Promise<T>;\n  update(document: T, options: DocumentWriteParameters): Promise<T>;\n  delete(query: DeleteQuery): Promise<DeleteResponse>;\n  import(\n    documents: T[] | string,\n    options: DocumentWriteParameters,\n  ): Promise<string | ImportResponse[]>;\n  export(options: DocumentsExportParameters): Promise<string>;\n}\n\nexport interface SearchOptions {\n  cacheSearchResultsForSeconds?: number;\n  abortSignal?: AbortSignal | null;\n}\n\nexport default class Documents<T extends DocumentSchema = object>\n  extends SearchOnlyDocuments<T>\n  implements WriteableDocuments<T>\n{\n  constructor(\n    collectionName: string,\n    apiCall: ApiCall,\n    configuration: Configuration,\n  ) {\n    super(collectionName, apiCall, configuration);\n  }\n\n  async create(document: T, options: DocumentWriteParameters = {}): Promise<T> {\n    if (!document) throw new Error(\"No document provided\");\n    return this.apiCall.post<T>(this.endpointPath(), document, options);\n  }\n\n  async upsert(document: T, options: DocumentWriteParameters = {}): Promise<T> {\n    if (!document) throw new Error(\"No document provided\");\n    return this.apiCall.post<T>(\n      this.endpointPath(),\n      document,\n      Object.assign({}, options, { action: \"upsert\" }),\n    );\n  }\n\n  async update(\n    document: T,\n    options: UpdateByFilterParameters,\n  ): Promise<UpdateByFilterResponse>;\n  async update(document: T, options: DocumentWriteParameters): Promise<T>;\n  async update(\n    document: T,\n    options: DocumentWriteParameters | UpdateByFilterParameters = {},\n  ): Promise<UpdateByFilterResponse | T> {\n    if (!document) throw new Error(\"No document provided\");\n\n    if (options[\"filter_by\"] != null) {\n      return this.apiCall.patch<T>(\n        this.endpointPath(),\n        document,\n        Object.assign({}, options),\n      );\n    } else {\n      return this.apiCall.post<T>(\n        this.endpointPath(),\n        document,\n        Object.assign({}, options, { action: \"update\" }),\n      );\n    }\n  }\n\n  async delete(\n    query: DeleteQuery = {} as DeleteQuery,\n  ): Promise<DeleteResponse> {\n    return this.apiCall.delete<DeleteResponse>(this.endpointPath(), query);\n  }\n\n  async createMany(documents: T[], options: DocumentImportParameters = {}) {\n    this.configuration.logger.warn(\n      \"createMany is deprecated and will be removed in a future version. Use import instead, which now takes both an array of documents or a JSONL string of documents\",\n    );\n    return this.import(documents, options);\n  }\n\n  /**\n   * Import a set of documents in a batch.\n   * @param {string|Array} documents - Can be a JSONL string of documents or an array of document objects.\n   * @param options\n   * @return {string|Array} Returns a JSONL string if the input was a JSONL string, otherwise it returns an array of results.\n   */\n  async import(\n    documents: string,\n    options?: DocumentImportParameters,\n  ): Promise<string>;\n  async import(\n    documents: T[],\n    options?: DocumentImportParameters,\n  ): Promise<ImportResponse[]>;\n  async import(\n    documents: T[] | string,\n    options: DocumentImportParameters = {},\n  ): Promise<string | ImportResponse[]> {\n    let documentsInJSONLFormat;\n    if (Array.isArray(documents)) {\n      try {\n        documentsInJSONLFormat = documents\n          .map((document) => JSON.stringify(document))\n          .join(\"\\n\");\n      } catch (error: any) {\n        // if rangeerror, throw custom error message\n        if (\n          error instanceof RangeError &&\n          error.message.includes(\"Too many properties to enumerate\")\n        ) {\n          throw new Error(`${error}\n          It looks like you have reached a Node.js limit that restricts the number of keys in an Object: https://stackoverflow.com/questions/9282869/are-there-limits-to-the-number-of-properties-in-a-javascript-object\n\n          Please try reducing the number of keys in your document, or using CURL to import your data.\n          `);\n        }\n\n        // else, throw the non-range error anyways\n        throw new Error(error);\n      }\n    } else {\n      documentsInJSONLFormat = documents;\n    }\n\n    const resultsInJSONLFormat = await this.apiCall.performRequest<string>(\n      \"post\",\n      this.endpointPath(\"import\"),\n      {\n        queryParameters: options,\n        bodyParameters: documentsInJSONLFormat,\n        additionalHeaders: { \"Content-Type\": \"text/plain\" },\n        skipConnectionTimeout: true, // We never want to client-side-timeout on an import and retry, since imports are syncronous and we want to let them take as long as it takes to complete fully\n        enableKeepAlive: true, // This is to prevent ECONNRESET socket hang up errors. Reference: https://github.com/axios/axios/issues/2936#issuecomment-779439991\n      },\n    );\n\n    if (Array.isArray(documents)) {\n      const resultsInJSONFormat = resultsInJSONLFormat\n        .split(\"\\n\")\n        .map((r) => JSON.parse(r)) as ImportResponse[];\n      const failedItems = resultsInJSONFormat.filter(\n        (r) => r.success === false,\n      );\n      if (failedItems.length > 0) {\n        throw new ImportError(\n          `${\n            resultsInJSONFormat.length - failedItems.length\n          } documents imported successfully, ${\n            failedItems.length\n          } documents failed during import. Use \\`error.importResults\\` from the raised exception to get a detailed error reason for each document.`,\n          resultsInJSONFormat,\n        );\n      } else {\n        return resultsInJSONFormat;\n      }\n    } else {\n      return resultsInJSONLFormat as string;\n    }\n  }\n\n  /**\n   * Returns a JSONL string for all the documents in this collection\n   */\n  async export(options: DocumentsExportParameters = {}): Promise<string> {\n    return this.apiCall.get<string>(this.endpointPath(\"export\"), options);\n  }\n\n  /**\n   * Returns a NodeJS readable stream of JSONL for all the documents in this collection.\n   */\n  async exportStream(\n    options: DocumentsExportParameters = {},\n  ): Promise<ReadStream> {\n    return this.apiCall.get<ReadStream>(this.endpointPath(\"export\"), options, {\n      responseType: \"stream\",\n    });\n  }\n}\n","import ApiCall from \"./ApiCall\";\nimport ConversationModels from \"./ConversationModels\";\nimport ConversationModel from \"./ConversationModel\";\nimport { ConversationSchema } from \"./Conversation\";\n\nconst RESOURCEPATH = \"/conversations\";\n\nexport interface ConversationsRetrieveSchema {\n  conversations: ConversationSchema[];\n}\n\nexport default class Conversations {\n  private readonly _conversationsModels: ConversationModels;\n  private readonly individualConversationModels: Record<\n    string,\n    ConversationModel\n  > = {};\n\n  constructor(private readonly apiCall: ApiCall) {\n    this.apiCall = apiCall;\n    this._conversationsModels = new ConversationModels(this.apiCall);\n  }\n\n  async retrieve(): Promise<ConversationsRetrieveSchema> {\n    return this.apiCall.get<ConversationsRetrieveSchema>(RESOURCEPATH);\n  }\n\n  models(): ConversationModels;\n  models(id: string): ConversationModel;\n  models(id?: string): ConversationModels | ConversationModel {\n    if (id === undefined) {\n      return this._conversationsModels;\n    } else {\n      if (this.individualConversationModels[id] === undefined) {\n        this.individualConversationModels[id] = new ConversationModel(\n          id,\n          this.apiCall,\n        );\n      }\n      return this.individualConversationModels[id];\n    }\n  }\n\n  static get RESOURCEPATH() {\n    return RESOURCEPATH;\n  }\n}\n"]}